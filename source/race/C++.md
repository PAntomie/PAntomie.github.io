---
date: 2025-09-30
---
### **1. 基本运算、三大基本结构、数组及结构体、数据类型转换**

#### **基本运算**

- **算术运算**：包括加（\+）、减（\-）、乘（\*）、除（/）、取模（%）等。
- **比较运算**：如 `==`（等于）、`!=`（不等于）、`>`（大于）、`<`（小于）等。
- **逻辑运算**：包括 `&&`（与）、`||`（或）、`!`（非）。
- **位运算**：如 `&`（按位与）、`|`（按位或）、`^`（异或）、`<<`（左移）、`>>`（右移）。

#### **三大基本结构**

1. **顺序结构**：程序按代码顺序执行，无需分支或循环。
2. **选择结构（分支）**：
   - `if-else`：根据条件判断执行不同代码块。
   - `switch-case`：多分支选择，适用于离散值的判断。
3. **循环结构**：
   - `for`：固定次数的循环，适合已知迭代次数的场景。
   - `while`：条件满足时持续循环，适合未知次数的场景。
   - `do-while`：先执行一次循环体，再判断条件是否继续。

#### **数组**

- **定义**：连续内存存储相同类型的数据，通过索引访问。

  ```cpp
  int arr[5] = {1, 2, 3, 4, 5}; // 定义一个长度为5的整型数组
  ```

- **用途**：存储和操作大量同类型数据，如学生成绩、矩阵等。
- **多维数组**：用于表示矩阵或表格数据。

  ```cpp
  int matrix[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}; // 3x3矩阵
  ```

#### **结构体（struct）**

- **定义**：自定义复合数据类型，可包含不同类型的成员。

  ```cpp
  struct Student {
      std::string name;
      int age;
      float gpa;
  };
  ```

- **用途**：将相关数据组合在一起，如学生信息、商品信息等。
- **初始化与访问**：

  ```cpp
  Student s1 = {"Alice", 20, 3.8};
  std::cout << s1.name; // 访问结构体成员
  ```

#### **数据类型转换**

1. **隐式转换（自动类型提升）**：
   - 低精度类型（如 `int`）自动转换为高精度类型（如 `double`）。

   ```cpp
   int a = 5;
   double b = a; // int 转 double
   ```

2. **显式转换（强制类型转换）**：
   - 使用 `static_cast<T>` 或 C 风格 `(T)`。

   ```cpp
   double c = 3.14;
   int d = static_cast<int>(c); // double 转 int
   ```

#### **简单数学函数**

- **标准库函数**（需包含 `<cmath>`）：
  - `sqrt(x)`：平方根。
  - `pow(x, y)`：幂运算。
  - `abs(x)`：绝对值。
  - `sin(x)`、`cos(x)`、`tan(x)`：三角函数。

#### **数据编码与进制转换**

- **编码**：
  - ASCII：字符与整数的映射（如 `'A'` 对应 65）。
  - Unicode：支持多语言字符集（如 UTF-8）。
- **进制转换**：
  - **二进制与十进制转换**：

    ```cpp
    int binary = 0b1010; // 二进制 1010 对应十进制 10
    std::cout << std::hex << 255; // 输出十六进制 FF
    ```

  - **手动转换**：
    - 十进制转二进制：不断除以 2 取余数。
    - 二进制转十进制：按权展开求和。

---

### **2. 枚举、排序、查找、递归、分治**

#### **枚举（enum）**

- **定义**：一组命名的整数常量集合。

  ```cpp
  enum Color { RED = 1, GREEN, BLUE }; // RED=1, GREEN=2, BLUE=3
  ```

- **用途**：提高代码可读性，如表示状态或选项。

#### **排序算法**

1. **插入排序**（如直接插入排序、希尔排序）：
   - 适合小规模数据，时间复杂度 $O(n^2)$。
2. **交换排序**（如冒泡排序）：
   - 通过相邻元素交换实现排序。
3. **选择排序**（如直接选择排序）：
   - 每次选择最小元素放入有序区。
4. **快速排序**：
   - 分治策略，平均时间复杂度 $O(n \log n)$。
   - 核心：选取基准值，将数组分为小于基准和大于基准的两部分。
5. **归并排序**：
   - 分治策略，稳定排序，时间复杂度 $O(n \log n)$。

#### **查找算法**

1. **顺序查找**：
   - 逐个比较元素，适用于无序数组。
2. **二分查找**：
   - 要求数组有序，时间复杂度 $O(\log n)$。
   - 步骤：取中间值，比较目标值与中间值，缩小搜索范围。

#### **递归**

- **定义**：函数直接或间接调用自身。
- **特点**：需有终止条件，否则会导致无限递归。
- **应用场景**：
  - 阶乘计算：`n! = n * (n-1)!`。
  - 汉诺塔问题：递归分解子问题。

  ```cpp
  void hanoi(int n, char from, char to, char aux) {
      if (n == 1) {
          std::cout << "Move disk 1 from " << from << " to " << to << std::endl;
          return;
      }
      hanoi(n-1, from, aux, to);
      std::cout << "Move disk " << n << " from " << from << " to " << to << std::endl;
      hanoi(n-1, aux, to, from);
  }
  ```

#### **分治（Divide and Conquer）**

- **核心思想**：将问题分解为子问题，分别解决后合并结果。
- **典型算法**：
  - 快速排序、归并排序。
  - 矩阵乘法（Strassen 算法）。
- **步骤**：
  1. 分解：将原问题拆分为多个子问题。
  2. 解决：递归地解决子问题。
  3. 合并：将子问题的解合并为原问题的解。

---

### **3. 高精度、栈、队列、链表、DFS、BFS**

#### **高精度计算**

- **定义**：处理超出基本数据类型范围的数值（如大整数或高精度浮点数）。
- **实现**：
  - 使用数组或字符串存储数字的每一位。
  - 手动模拟加减乘除运算。

  ```cpp
  std::string add(std::string a, std::string b) {
      std::string result;
      int carry = 0;
      int i = a.length() - 1, j = b.length() - 1;
      while (i >= 0 || j >= 0 || carry > 0) {
          int sum = carry;
          if (i >= 0) sum += a[i--] - '0';
          if (j >= 0) sum += b[j--] - '0';
          carry = sum / 10;
          result.push_back(sum % 10 + '0');
      }
      std::reverse(result.begin(), result.end());
      return result;
  }
  ```

#### **栈（Stack）**

- **特性**：后进先出（LIFO）。
- **操作**：
  - `push(x)`：压入元素。
  - `pop()`：弹出元素。
  - `top()`：查看栈顶元素。
- **应用场景**：
  - 表达式求值（如括号匹配）。
  - 函数调用栈（递归实现）。
  - 深度优先搜索（DFS）。

#### **队列（Queue）**

- **特性**：先进先出（FIFO）。
- **操作**：
  - `enqueue(x)`：入队。
  - `dequeue()`：出队。
  - `front()`：查看队首元素。
- **应用场景**：
  - 广度优先搜索（BFS）。
  - 操作系统任务调度。

#### **链表（Linked List）**

- **类型**：
  - 单向链表：每个节点指向下一个节点。
  - 双向链表：每个节点指向前驱和后继。
  - 循环链表：尾节点指向头节点。
- **操作**：
  - 插入、删除、查找。
  - 示例：反转链表、合并两个有序链表。

#### **DFS（深度优先搜索）**

- **原理**：沿着一条路径尽可能深入，回溯后再探索其他路径。
- **实现**：递归或栈。
- **应用场景**：
  - 迷宫问题。
  - 图的遍历。
  - 拓扑排序。

#### **BFS（广度优先搜索）**

- **原理**：逐层扩展，优先探索当前节点的所有邻居。
- **实现**：队列。
- **应用场景**：
  - 最短路径问题（无权图）。
  - 社交网络中的好友推荐。

---

### **4. 初等数论、树和图、动态规划**

#### **初等数论**

- **基本概念**：
  - **素数**：仅能被 1 和自身整除的数。
  - **最大公约数（GCD）**：欧几里得算法（辗转相除法）。
  - **模运算**：取余操作，常用于循环和密码学。
- **应用**：
  - RSA 加密算法依赖大数分解和模运算。
  - 快速幂算法：计算 $a^b \mod m$。

#### **树和图**

- **树**：
  - **二叉树**：每个节点最多有两个子节点。
  - **二叉搜索树（BST）**：左子树 < 根 < 右子树，支持快速查找。
  - **平衡树**（如 AVL 树、红黑树）：通过旋转保持树的平衡。
- **图**：
  - **表示方法**：
    - 邻接矩阵：二维数组存储边关系。
    - 邻接表：链表或数组存储每个节点的邻居。
  - **遍历算法**：
    - DFS：深度优先搜索。
    - BFS：广度优先搜索。
  - **最短路径算法**：
    - Dijkstra 算法（单源最短路径，无负权边）。
    - Floyd-Warshall 算法（所有节点对最短路径）。

#### **动态规划（Dynamic Programming, DP）**

- **核心思想**：将问题分解为重叠子问题，存储子问题的解以避免重复计算。
- **步骤**：
  1. **定义状态**：确定问题的状态表示（如 `dp[i]` 表示前 `i` 项的最优解）。
  2. **状态转移方程**：建立状态之间的递推关系。
  3. **初始条件**：设置初始状态的值。
  4. **计算顺序**：按顺序填充状态表。
- **经典问题**：
  - **斐波那契数列**：

    ```cpp
    int fib(int n) {
        if (n <= 1) return n;
        std::vector<int> dp(n+1);
        dp[0] = 0, dp[1] = 1;
        for (int i=2; i<=n; ++i) dp[i] = dp[i-1] + dp[i-2];
        return dp[n];
    }
    ```

  - **背包问题**：0-1 背包、完全背包。
  - **最长公共子序列（LCS）**：比较两个序列的最长公共子序列长度。

---

### **总结**

以上内容涵盖了 C++ 的基础语法、数据结构、算法设计与分析的核心知识。掌握这些内容是编写高效、可靠程序的关键。实际开发中，需根据问题特点选择合适的数据结构和算法，并结合调试和优化手段提升性能。
